{"version":3,"file":"basedecoder-07ibxAr6.js","sources":["../../node_modules/geotiff/dist-module/predictor.js","../../node_modules/geotiff/dist-module/compression/basedecoder.js"],"sourcesContent":["function decodeRowAcc(row, stride) {\n  let length = row.length - stride;\n  let offset = 0;\n  do {\n    for (let i = stride; i > 0; i--) {\n      row[offset + stride] += row[offset];\n      offset++;\n    }\n\n    length -= stride;\n  } while (length > 0);\n}\n\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n  let index = 0;\n  let count = row.length;\n  const wc = count / bytesPerSample;\n\n  while (count > stride) {\n    for (let i = stride; i > 0; --i) {\n      row[index + stride] += row[index];\n      ++index;\n    }\n    count -= stride;\n  }\n\n  const copy = row.slice();\n  for (let i = 0; i < wc; ++i) {\n    for (let b = 0; b < bytesPerSample; ++b) {\n      row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n    }\n  }\n}\n\nexport function applyPredictor(block, predictor, width, height, bitsPerSample,\n  planarConfiguration) {\n  if (!predictor || predictor === 1) {\n    return block;\n  }\n\n  for (let i = 0; i < bitsPerSample.length; ++i) {\n    if (bitsPerSample[i] % 8 !== 0) {\n      throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n    }\n    if (bitsPerSample[i] !== bitsPerSample[0]) {\n      throw new Error('When decoding with predictor, all samples must have the same size.');\n    }\n  }\n\n  const bytesPerSample = bitsPerSample[0] / 8;\n  const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n\n  for (let i = 0; i < height; ++i) {\n    // Last strip will be truncated if height % stripHeight != 0\n    if (i * stride * width * bytesPerSample >= block.byteLength) {\n      break;\n    }\n    let row;\n    if (predictor === 2) { // horizontal prediction\n      switch (bitsPerSample[0]) {\n        case 8:\n          row = new Uint8Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n          );\n          break;\n        case 16:\n          row = new Uint16Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2,\n          );\n          break;\n        case 32:\n          row = new Uint32Array(\n            block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4,\n          );\n          break;\n        default:\n          throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n      }\n      decodeRowAcc(row, stride, bytesPerSample);\n    } else if (predictor === 3) { // horizontal floating point\n      row = new Uint8Array(\n        block, i * stride * width * bytesPerSample, stride * width * bytesPerSample,\n      );\n      decodeRowFloatingPoint(row, stride, bytesPerSample);\n    }\n  }\n  return block;\n}\n","import { applyPredictor } from '../predictor.js';\n\nexport default class BaseDecoder {\n  async decode(fileDirectory, buffer) {\n    const decoded = await this.decodeBlock(buffer);\n    const predictor = fileDirectory.Predictor || 1;\n    if (predictor !== 1) {\n      const isTiled = !fileDirectory.StripOffsets;\n      const tileWidth = isTiled ? fileDirectory.TileWidth : fileDirectory.ImageWidth;\n      const tileHeight = isTiled ? fileDirectory.TileLength : (\n        fileDirectory.RowsPerStrip || fileDirectory.ImageLength\n      );\n      return applyPredictor(\n        decoded, predictor, tileWidth, tileHeight, fileDirectory.BitsPerSample,\n        fileDirectory.PlanarConfiguration,\n      );\n    }\n    return decoded;\n  }\n}\n"],"names":["decodeRowAcc","row","stride","length","offset","i","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","slice","b","BaseDecoder","decode","fileDirectory","buffer","decoded","this","decodeBlock","predictor","Predictor","isTiled","StripOffsets","block","width","height","bitsPerSample","planarConfiguration","Error","byteLength","Uint8Array","Uint16Array","Uint32Array","applyPredictor","TileWidth","ImageWidth","TileLength","RowsPerStrip","ImageLength","BitsPerSample","PlanarConfiguration"],"mappings":"AAAA,SAASA,EAAaC,EAAKC,GACrB,IAAAC,EAASF,EAAIE,OAASD,EACtBE,EAAS,EACV,EAAA,CACD,IAAA,IAASC,EAAIH,EAAQG,EAAI,EAAGA,IAC1BJ,EAAIG,EAASF,IAAWD,EAAIG,GAC5BA,IAGQD,GAAAD,CACX,OAAQC,EAAS,EACpB,CAEA,SAASG,EAAuBL,EAAKC,EAAQK,GAC3C,IAAIC,EAAQ,EACRC,EAAQR,EAAIE,OAChB,MAAMO,EAAKD,EAAQF,EAEnB,KAAOE,EAAQP,GAAQ,CACrB,IAAA,IAASG,EAAIH,EAAQG,EAAI,IAAKA,EAC5BJ,EAAIO,EAAQN,IAAWD,EAAIO,KACzBA,EAEKC,GAAAP,CACb,CAEQ,MAAAS,EAAOV,EAAIW,QACjB,IAAA,IAASP,EAAI,EAAGA,EAAIK,IAAML,EACxB,IAAA,IAASQ,EAAI,EAAGA,EAAIN,IAAkBM,EAC/BZ,EAAAM,EAAiBF,EAAKQ,GAAKF,GAAOJ,EAAiBM,EAAI,GAAKH,EAAML,EAG7E,CC9Be,MAAMS,EACnB,YAAMC,CAAOC,EAAeC,GAC1B,MAAMC,QAAgBC,KAAKC,YAAYH,GACjCI,EAAYL,EAAcM,WAAa,EAC7C,GAAkB,IAAdD,EAAiB,CACb,MAAAE,GAAWP,EAAcQ,aAKxB,ODsBN,SAAwBC,EAAOJ,EAAWK,EAAOC,EAAQC,EAC9DC,GACA,GAAgC,IAAdR,EACT,OAAAI,EAGT,IAAA,IAASpB,EAAI,EAAGA,EAAIuB,EAAczB,SAAUE,EAAG,CAC7C,GAAIuB,EAAcvB,GAAK,GAAM,EACrB,MAAA,IAAIyB,MAAM,wEAElB,GAAIF,EAAcvB,KAAOuB,EAAc,GAC/B,MAAA,IAAIE,MAAM,qEAEtB,CAEQ,MAAAvB,EAAiBqB,EAAc,GAAK,EACpC1B,EAAiC,IAAxB2B,EAA4B,EAAID,EAAczB,OAE7D,IAAA,IAASE,EAAI,EAAGA,EAAIsB,KAEdtB,EAAIH,EAASwB,EAAQnB,GAAkBkB,EAAMM,cAFrB1B,EAAG,CAK3B,IAAAJ,EACJ,GAAkB,IAAdoB,EAAiB,CACX,OAAAO,EAAc,IACpB,KAAK,EACH3B,EAAM,IAAI+B,WACRP,EAAOpB,EAAIH,EAASwB,EAAQnB,EAAgBL,EAASwB,EAAQnB,GAE/D,MACF,KAAK,GACHN,EAAM,IAAIgC,YACRR,EAAOpB,EAAIH,EAASwB,EAAQnB,EAAgBL,EAASwB,EAAQnB,EAAiB,GAEhF,MACF,KAAK,GACHN,EAAM,IAAIiC,YACRT,EAAOpB,EAAIH,EAASwB,EAAQnB,EAAgBL,EAASwB,EAAQnB,EAAiB,GAEhF,MACF,QACE,MAAM,IAAIuB,MAAM,gCAAgCF,EAAc,uBAElE5B,EAAaC,EAAKC,EACxB,MAA6B,IAAdmB,IACTpB,EAAM,IAAI+B,WACRP,EAAOpB,EAAIH,EAASwB,EAAQnB,EAAgBL,EAASwB,EAAQnB,GAExCD,EAAAL,EAAKC,EAAQK,GAE1C,CACS,OAAAkB,CACT,CC3EaU,CACLjB,EAASG,EALOE,EAAUP,EAAcoB,UAAYpB,EAAcqB,WACjDd,EAAUP,EAAcsB,WACzCtB,EAAcuB,cAAgBvB,EAAcwB,YAGDxB,EAAcyB,cACzDzB,EAAc0B,oBAEtB,CACW,OAAAxB,CACX","x_google_ignoreList":[0,1]}