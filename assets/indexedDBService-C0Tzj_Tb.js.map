{"version":3,"file":"indexedDBService-C0Tzj_Tb.js","sources":["../../node_modules/idb/build/index.js","../../src/services/indexedDBService.ts"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","import { openDB, IDBPDatabase } from 'idb';\nimport type { FeatureCollection } from 'geojson';\nimport type { ProcessedImage } from './imageProcessor';\n\nconst DB_NAME = 'shorelineDB';\nconst DB_VERSION = 2; // Increased version to handle schema updates\nconst SHORELINE_STORE = 'shorelineData';\nconst IMAGE_STORE = 'satelliteImages';\n\ninterface ShorelineStore {\n  id: string;\n  data: FeatureCollection;\n  timestamp: number;\n}\n\ninterface ImageStore {\n  id: string;\n  data: ProcessedImage;\n  timestamp: number;\n}\n\nclass IndexedDBService {\n  private db: IDBPDatabase | null = null;\n\n  async initialize(): Promise<void> {\n    try {\n      this.db = await openDB(DB_NAME, DB_VERSION, {\n        upgrade(db) {\n          // Create the shoreline store if it doesn't exist\n          if (!db.objectStoreNames.contains(SHORELINE_STORE)) {\n            db.createObjectStore(SHORELINE_STORE, { keyPath: 'id' });\n          }\n\n          // Create the satellite image store if it doesn't exist\n          if (!db.objectStoreNames.contains(IMAGE_STORE)) {\n            db.createObjectStore(IMAGE_STORE, { keyPath: 'id' });\n          }\n        },\n        blocked() {\n          console.warn('Database upgrade blocked. Please close other tabs/windows using this application.');\n        },\n        blocking() {\n          console.warn('Database is blocking other connections. Closing current connection.');\n        },\n      });\n    } catch (error) {\n      console.error('Failed to initialize IndexedDB:', error);\n\n      // Handle version mismatch by deleting and recreating the database\n      if (error instanceof DOMException &&\n          (error.name === 'VersionError' ||\n           error.message.includes('higher version') ||\n           error.message.includes('version requested'))) {\n        console.warn('Database version mismatch detected. Recreating database...');\n        try {\n          await this.deleteDatabase();\n          // Wait a bit for the deletion to complete\n          await new Promise(resolve => setTimeout(resolve, 100));\n          return this.initialize();\n        } catch (deleteError) {\n          console.error('Failed to delete and recreate database:', deleteError);\n          throw new Error('Database version conflict. Please refresh the page or clear your browser data.');\n        }\n      }\n\n      throw new Error('Failed to initialize database storage. Please try again.');\n    }\n  }\n\n  private async deleteDatabase(): Promise<void> {\n    return new Promise((resolve, reject) => {\n      const deleteRequest = indexedDB.deleteDatabase(DB_NAME);\n\n      deleteRequest.onsuccess = () => {\n        console.log('Database deleted successfully');\n        resolve();\n      };\n\n      deleteRequest.onerror = () => {\n        console.error('Failed to delete database:', deleteRequest.error);\n        reject(deleteRequest.error);\n      };\n\n      deleteRequest.onblocked = () => {\n        console.warn('Database deletion blocked. Please close other tabs/windows using this application.');\n        // Still resolve to allow retry\n        resolve();\n      };\n    });\n  }\n\n  // Shoreline data methods\n  async storeShorelineData(id: string, data: FeatureCollection): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    try {\n      const storeData: ShorelineStore = {\n        id,\n        data,\n        timestamp: Date.now(),\n      };\n      await this.db!.put(SHORELINE_STORE, storeData);\n    } catch (error) {\n      console.error('Failed to store shoreline data:', error);\n      if (error instanceof Error && error.name === 'QuotaExceededError') {\n        throw new Error('Storage quota exceeded. Please try with a smaller file or clear some space.');\n      }\n      throw new Error('Failed to store shoreline data. Please try again.');\n    }\n  }\n\n  async getShorelineData(id: string): Promise<FeatureCollection | null> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    try {\n      const result: ShorelineStore | undefined = await this.db!.get(SHORELINE_STORE, id);\n      return result ? result.data : null;\n    } catch (error) {\n      console.error('Failed to retrieve shoreline data:', error);\n      throw new Error('Failed to retrieve shoreline data. Please try again.');\n    }\n  }\n\n  async deleteShorelineData(id: string): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    try {\n      await this.db!.delete(SHORELINE_STORE, id);\n    } catch (error) {\n      console.error('Failed to delete shoreline data:', error);\n      throw new Error('Failed to delete shoreline data. Please try again.');\n    }\n  }\n\n  async clearAllShorelineData(): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    try {\n      await this.db!.clear(SHORELINE_STORE);\n    } catch (error) {\n      console.error('Failed to clear shoreline data:', error);\n      throw new Error('Failed to clear shoreline data. Please try again.');\n    }\n  }\n\n  // Satellite image methods\n  async storeSatelliteImage(id: string, data: ProcessedImage): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    try {\n      let processedBlob: Blob | undefined;\n\n      // If we have a georaster, convert it to a web-compatible format\n      if (data.georaster && data.georaster.toCanvas) {\n        try {\n          // Convert georaster to canvas (web-compatible raster format)\n          console.log('Georaster info:', {\n            width: data.georaster.width,\n            height: data.georaster.height,\n            numberOfRasters: data.georaster.numberOfRasters,\n            mins: data.georaster.mins,\n            maxs: data.georaster.maxs,\n            ranges: data.georaster.ranges,\n            noDataValue: data.georaster.noDataValue\n          });\n\n          const canvas = data.georaster.toCanvas({\n            width: Math.min(1024, data.georaster.width), // Limit size for performance\n            height: Math.min(1024, data.georaster.height),\n            pixelValuesToColorFn: (values: number[]) => {\n              // Log first few pixel values to understand the data range\n              if (Math.random() < 0.001) { // Log 0.1% of pixels to avoid spam\n                console.log('Sample pixel values:', values);\n              }\n\n              // Handle different band configurations\n              if (values.length >= 3) {\n                // RGB or multi-band image\n                const [r, g, b] = values;\n                \n                // Get the actual min/max ranges from georaster\n                const rMin = data.georaster.mins?.[0] || 0;\n                const rMax = data.georaster.maxs?.[0] || 255;\n                const gMin = data.georaster.mins?.[1] || 0;\n                const gMax = data.georaster.maxs?.[1] || 255;\n                const bMin = data.georaster.mins?.[2] || 0;\n                const bMax = data.georaster.maxs?.[2] || 255;\n                \n                // Normalize values based on actual data range\n                const normalizeValue = (val: number, min: number, max: number) => {\n                  if (val === null || val === undefined || !isFinite(val)) return 0;\n                  if (val === data.georaster.noDataValue) return 0;\n                  // Normalize from [min, max] to [0, 255]\n                  const normalized = ((val - min) / (max - min)) * 255;\n                  return Math.max(0, Math.min(255, Math.round(normalized)));\n                };\n                \n                return `rgb(${normalizeValue(r, rMin, rMax)}, ${normalizeValue(g, gMin, gMax)}, ${normalizeValue(b, bMin, bMax)})`;\n              } else if (values.length === 1) {\n                // Single band (grayscale)\n                const val = values[0];\n                if (val === null || val === undefined || !isFinite(val)) return 'rgba(0,0,0,0)';\n                if (val === data.georaster.noDataValue) return 'rgba(0,0,0,0)';\n                \n                // Get the actual min/max range for single band\n                const min = data.georaster.mins?.[0] || 0;\n                const max = data.georaster.maxs?.[0] || 255;\n                \n                // Normalize from [min, max] to [0, 255]\n                const normalized = ((val - min) / (max - min)) * 255;\n                const clampedValue = Math.max(0, Math.min(255, Math.round(normalized)));\n                return `rgb(${clampedValue}, ${clampedValue}, ${clampedValue})`;\n              }\n              return 'rgba(0,0,0,0)'; // Transparent for invalid values\n            }\n          });\n          \n          // Convert canvas to blob (binary data for storage)\n          processedBlob = await new Promise<Blob>((resolve, reject) => {\n            canvas.toBlob((blob: Blob | null) => {\n              if (blob) {\n                resolve(blob);\n              } else {\n                reject(new Error('Failed to convert canvas to blob'));\n              }\n            }, 'image/png', 0.9); // High quality PNG\n          });\n\n          console.log('Converted georaster to web-compatible blob format');\n        } catch (error) {\n          console.warn('Failed to convert georaster to blob, storing metadata only:', error);\n        }\n      }\n\n      // Create serializable data for storage\n      const serializableData = {\n        id: data.id,\n        name: data.name,\n        bounds: data.bounds,\n        timestamp: data.timestamp,\n        metadata: data.metadata,\n        url: null, // Will be created on retrieval\n        processedBlob: processedBlob // Store the processed raster data\n        // Don't store the heavy georaster or arrayBuffer objects\n      };\n\n      const storeData: ImageStore = {\n        id,\n        data: serializableData as ProcessedImage,\n        timestamp: Date.now(),\n      };\n      \n      await this.db!.put(IMAGE_STORE, storeData);\n      console.log('Satellite image stored successfully with processed blob');\n    } catch (error) {\n      console.error('Failed to store satellite image:', error);\n      if (error instanceof Error && error.name === 'QuotaExceededError') {\n        throw new Error('Storage quota exceeded. Please try with a smaller file or clear some space.');\n      }\n      throw new Error('Failed to store satellite image. Please try again.');\n    }\n  }\n\n  async getSatelliteImage(id: string): Promise<ProcessedImage | null> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    try {\n      const result: ImageStore | undefined = await this.db!.get(IMAGE_STORE, id);\n      if (!result) {\n        return null;\n      }\n\n      const storedData = result.data;\n      \n      // If we have a processed blob but no current URL, create a new Object URL\n      if ((storedData as any).processedBlob && !storedData.url) {\n        try {\n          // Create a data URL instead of blob URL to avoid CORS issues\n          const blob = (storedData as any).processedBlob;\n          const reader = new FileReader();\n          \n          const dataUrl = await new Promise<string>((resolve, reject) => {\n            reader.onload = () => resolve(reader.result as string);\n            reader.onerror = () => reject(reader.error);\n            reader.readAsDataURL(blob);\n          });\n          \n          storedData.url = dataUrl;\n          console.log('Created data URL for stored processed blob');\n        } catch (error) {\n          console.warn('Failed to create data URL from stored blob:', error);\n        }\n      }\n\n      return storedData;\n    } catch (error) {\n      console.error('Failed to retrieve satellite image:', error);\n      throw new Error('Failed to retrieve satellite image. Please try again.');\n    }\n  }\n\n  async getAllSatelliteImages(): Promise<ProcessedImage[]> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    try {\n      const allImages: ImageStore[] = await this.db!.getAll(IMAGE_STORE);\n      \n      // Process each image to recreate data URLs from stored blobs if needed\n      const processedImages = await Promise.all(\n        allImages.map(async (item) => {\n          const storedData = item.data;\n          \n          // If we have a processed blob but no current URL, create a new data URL\n          if ((storedData as any).processedBlob && !storedData.url) {\n            try {\n              // Create a data URL instead of blob URL to avoid CORS issues\n              const blob = (storedData as any).processedBlob;\n              const reader = new FileReader();\n              \n              const dataUrl = await new Promise<string>((resolve, reject) => {\n                reader.onload = () => resolve(reader.result as string);\n                reader.onerror = () => reject(reader.error);\n                reader.readAsDataURL(blob);\n              });\n              \n              storedData.url = dataUrl;\n              console.log('Created data URL for stored processed blob');\n            } catch (error) {\n              console.warn('Failed to create data URL from stored blob for image:', storedData.id, error);\n            }\n          }\n          \n          return storedData;\n        })\n      );\n\n      return processedImages;\n    } catch (error) {\n      console.error('Failed to retrieve satellite images:', error);\n      throw new Error('Failed to retrieve satellite images. Please try again.');\n    }\n  }\n\n  async deleteSatelliteImage(id: string): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    try {\n      await this.db!.delete(IMAGE_STORE, id);\n    } catch (error) {\n      console.error('Failed to delete satellite image:', error);\n      throw new Error('Failed to delete satellite image. Please try again.');\n    }\n  }\n\n  async clearAllSatelliteImages(): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    try {\n      await this.db!.clear(IMAGE_STORE);\n    } catch (error) {\n      console.error('Failed to clear satellite images:', error);\n      throw new Error('Failed to clear satellite images. Please try again.');\n    }\n  }\n\n  // General methods\n  async clearAllData(): Promise<void> {\n    if (!this.db) {\n      await this.initialize();\n    }\n\n    try {\n      await this.db!.clear(SHORELINE_STORE);\n      await this.db!.clear(IMAGE_STORE);\n    } catch (error) {\n      console.error('Failed to clear all data:', error);\n      throw new Error('Failed to clear all data. Please try again.');\n    }\n  }\n\n  // Development utility method to completely reset the database\n  async resetDatabase(): Promise<void> {\n    try {\n      if (this.db) {\n        this.db.close();\n        this.db = null;\n      }\n      await this.deleteDatabase();\n      await this.initialize();\n      console.log('Database reset successfully');\n    } catch (error) {\n      console.error('Failed to reset database:', error);\n      throw new Error('Failed to reset database. Please try again.');\n    }\n  }\n}\n\n// Export a singleton instance\nexport const indexedDBService = new IndexedDBService();\n"],"names":["target"],"mappings":"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","x_google_ignoreList":[0]}