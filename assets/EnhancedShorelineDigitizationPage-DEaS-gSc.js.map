{"version":3,"file":"EnhancedShorelineDigitizationPage-DEaS-gSc.js","sources":["../../node_modules/@heroicons/react/24/outline/esm/TrashIcon.js","../../src/components/maps/GeoRasterLeafletMap.tsx","../../src/pages/EnhancedShorelineDigitizationPage.tsx"],"sourcesContent":["import * as React from \"react\";\nfunction TrashIcon({\n  title,\n  titleId,\n  ...props\n}, svgRef) {\n  return /*#__PURE__*/React.createElement(\"svg\", Object.assign({\n    xmlns: \"http://www.w3.org/2000/svg\",\n    fill: \"none\",\n    viewBox: \"0 0 24 24\",\n    strokeWidth: 1.5,\n    stroke: \"currentColor\",\n    \"aria-hidden\": \"true\",\n    \"data-slot\": \"icon\",\n    ref: svgRef,\n    \"aria-labelledby\": titleId\n  }, props), title ? /*#__PURE__*/React.createElement(\"title\", {\n    id: titleId\n  }, title) : null, /*#__PURE__*/React.createElement(\"path\", {\n    strokeLinecap: \"round\",\n    strokeLinejoin: \"round\",\n    d: \"m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0\"\n  }));\n}\nconst ForwardRef = /*#__PURE__*/ React.forwardRef(TrashIcon);\nexport default ForwardRef;","import React, { useEffect, useRef, useState } from 'react';\nimport L from 'leaflet';\nimport 'leaflet/dist/leaflet.css';\nimport 'leaflet-draw';\nimport 'leaflet-draw/dist/leaflet.draw.css';\nimport GeoRasterLayer from 'georaster-layer-for-leaflet';\n// Import georaster as default export\nimport parseGeoraster from 'georaster';\nimport type { FeatureCollection, LineString, GeoJsonObject } from 'geojson';\nimport type { ProcessedImage } from '../../services/imageProcessor';\n\n// Extend the Leaflet Map type to include our custom properties\ndeclare module 'leaflet' {\n  interface Map {\n    _cleanupHandlers?: Array<() => void>;\n  }\n}\n\n// Extend GeoRasterLayer options to include our custom properties\ndeclare module 'georaster-layer-for-leaflet' {\n  interface GeoRasterLayerOptions {\n    debugLevel?: number;\n    renderTimeout?: number;\n    keepBuffer?: number;\n    updateWhenIdle?: boolean;\n    updateWhenZooming?: boolean;\n    resampleMethod?: 'nearest' | 'bilinear';\n  }\n}\n\ninterface GeoRasterLeafletMapProps {\n  images?: ProcessedImage[];\n  geoJSON?: FeatureCollection | null;\n  initialBounds?: number[] | null; // [minX, minY, maxX, maxY]\n  onLineStringCreate?: (lineString: LineString) => void;\n  onLineStringDelete?: (id: string) => void;\n  drawingEnabled?: boolean;\n  readOnly?: boolean;\n}\n\nconst GeoRasterLeafletMap: React.FC<GeoRasterLeafletMapProps> = ({\n  images = [],\n  geoJSON = null,\n  initialBounds = null,\n  onLineStringCreate,\n  onLineStringDelete,\n  drawingEnabled = true,\n  readOnly = false,\n}) => {\n  // Log images for debugging\n  console.log('GeoRasterLeafletMap received images:', images.map(img => ({\n    id: img.id,\n    name: img.name,\n    bounds: img.bounds,\n    hasGeoraster: !!img.georaster,\n    isJP2: img.metadata?.isJP2,\n    isSentinel: img.metadata?.isSentinel\n  })));\n  const mapRef = useRef<L.Map | null>(null);\n  const drawControlRef = useRef<L.Control.Draw | null>(null);\n  const geoJSONLayerRef = useRef<L.GeoJSON | null>(null);\n  const drawnItemsRef = useRef<L.FeatureGroup | null>(null);\n  const imageLayersRef = useRef<any[]>([]);\n  const [isMapInitialized, setIsMapInitialized] = useState(false);\n\n  // Initialize the map\n  useEffect(() => {\n    if (mapRef.current) return; // Map already initialized\n\n    try {\n      // Check if WebGL is available for potential hardware acceleration\n      const useWebGL = (() => {\n        try {\n          const canvas = document.createElement('canvas');\n          return !!(window.WebGLRenderingContext &&\n            (canvas.getContext('webgl') || canvas.getContext('experimental-webgl')));\n        } catch (e) {\n          return false;\n        }\n      })();\n\n      console.log(`WebGL ${useWebGL ? 'is' : 'is not'} available for hardware acceleration`);\n\n      // Apply advanced hardware acceleration optimizations\n      // These optimizations will be applied regardless of WebGL availability\n      // as they can still improve performance with the Canvas renderer\n      const style = document.createElement('style');\n      style.textContent = `\n        /* Core map container optimizations */\n        #georaster-leaflet-map {\n          will-change: transform;\n          transform: translateZ(0);\n          backface-visibility: hidden;\n          perspective: 1000px;\n          -webkit-perspective: 1000px;\n        }\n\n        /* Tile container optimizations */\n        .leaflet-tile-container {\n          will-change: transform;\n          transform: translateZ(0);\n          backface-visibility: hidden;\n          perspective: 1000px;\n          -webkit-perspective: 1000px;\n        }\n\n        /* Individual tile optimizations */\n        .leaflet-tile {\n          will-change: transform;\n          backface-visibility: hidden;\n          -webkit-transform: translateZ(0);\n          transform: translateZ(0);\n          image-rendering: -webkit-optimize-contrast; /* Sharper image rendering */\n        }\n\n        /* Pane optimizations */\n        .leaflet-pane {\n          will-change: transform;\n          transform: translateZ(0);\n          backface-visibility: hidden;\n        }\n\n        /* Layer optimizations */\n        .leaflet-layer {\n          will-change: transform;\n          transform: translateZ(0);\n          backface-visibility: hidden;\n        }\n\n        /* Zoom animation optimizations */\n        .leaflet-zoom-animated {\n          will-change: transform;\n          transform: translateZ(0);\n          backface-visibility: hidden;\n          transition-timing-function: cubic-bezier(0.215, 0.610, 0.355, 1.000);\n        }\n      `;\n      document.head.appendChild(style);\n\n      // Apply additional WebGL-specific optimizations if available\n      if (useWebGL) {\n        // Add WebGL-specific optimizations\n        const webGLStyle = document.createElement('style');\n        webGLStyle.textContent = `\n          /* WebGL-specific optimizations */\n          .leaflet-canvas-layer {\n            will-change: transform;\n            transform: translateZ(0);\n            backface-visibility: hidden;\n          }\n        `;\n        document.head.appendChild(webGLStyle);\n      }\n      // Create map instance with highly optimized options for perfect zooming\n      const mapInstance = L.map('georaster-leaflet-map', {\n        center: [20, 0],\n        zoom: 2,\n        zoomControl: true,\n        // Use canvas renderer for better performance with raster layers\n        preferCanvas: true,\n        // Enable smooth animations but with performance optimizations\n        fadeAnimation: true,\n        zoomAnimation: true,\n        // Disable marker animations for better performance\n        markerZoomAnimation: false,\n        // Increase max zoom level with better granularity\n        maxZoom: 22,\n        minZoom: 1,\n        // Advanced performance options - increased debounce time for better performance\n        wheelDebounceTime: 40, // Increased debounce for better performance during zooming\n        wheelPxPerZoomLevel: 60, // More sensitive zoom for smoother transitions\n        // High-performance renderer with optimized settings\n        renderer: L.canvas({\n          padding: 2.0, // Increased padding for smoother edge transitions\n          tolerance: 8   // Higher tolerance for better performance\n        }),\n        // Advanced zoom options for smoother transitions\n        zoomSnap: 0.5, // Increased for better performance (less granular but faster)\n        zoomDelta: 0.5, // Increased for better performance\n        trackResize: true, // Enable resize tracking for responsive layouts\n        // Additional performance optimizations\n        bounceAtZoomLimits: false, // Prevent bouncing at zoom limits\n        // Reduce animation duration for faster zooming\n        zoomAnimationThreshold: 4, // Allow animation for larger zoom changes\n        inertia: true, // Enable inertia for smoother panning\n        inertiaDeceleration: 3000, // Higher value for faster deceleration\n        worldCopyJump: true // Better handling of panning across date line\n      });\n      mapRef.current = mapInstance;\n\n      // Add high-performance base tile layer with advanced caching\n      L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {\n        attribution: 'Â© <a href=\"https://www.openstreetmap.org/copyright\">OpenStreetMap</a> contributors',\n        maxZoom: 22, // Match map's max zoom\n        minZoom: 1,  // Match map's min zoom\n        // Advanced caching and performance options - optimized for zooming\n        updateWhenIdle: true, // Only update when idle for better performance\n        updateWhenZooming: false, // Don't update during zoom for better performance\n        keepBuffer: 4, // Reduced buffer size for better performance\n        // Additional performance optimizations\n        crossOrigin: true, // Enable CORS for better caching\n        detectRetina: true, // Better display on high-DPI screens\n        className: 'base-tile-layer', // Add class for potential CSS optimizations\n        // Improved loading strategy\n        subdomains: 'abc', // Use all available subdomains for parallel loading\n        errorTileUrl: '', // Empty string to prevent error tile display\n        zIndex: 1, // Lower z-index to ensure it's below our raster layers\n        // Improved tile loading\n        tileSize: 256, // Standard tile size\n        zoomOffset: 0, // No zoom offset\n        opacity: 0.7, // Slightly transparent to better see our raster data\n        // Additional performance settings\n        pane: 'tilePane', // Ensure it's in the tile pane for proper layering\n        maxNativeZoom: 19, // Maximum zoom level of the tile server\n        bounds: L.latLngBounds([-90, -180], [90, 180]), // Limit to world bounds\n      }).addTo(mapInstance);\n\n      // Create feature group for drawn items\n      const drawnItemsInstance = new L.FeatureGroup();\n      mapInstance.addLayer(drawnItemsInstance);\n      drawnItemsRef.current = drawnItemsInstance;\n\n      // Force a redraw after initialization\n      setTimeout(() => {\n        mapInstance.invalidateSize();\n        console.log('Map size invalidated after initialization');\n      }, 100);\n\n      setIsMapInitialized(true);\n      console.log('GeoRasterLeafletMap: Map instance created.');\n    } catch (error) {\n      console.error(\"GeoRasterLeafletMap: Error initializing map:\", error);\n    }\n\n    // Advanced cleanup function with memory management\n    return () => {\n      if (mapRef.current) {\n        console.log('GeoRasterLeafletMap: Performing comprehensive cleanup.');\n\n        // First, remove all layers to free up memory\n        if (imageLayersRef.current && imageLayersRef.current.length > 0) {\n          console.log(`Removing ${imageLayersRef.current.length} image layers`);\n          imageLayersRef.current.forEach(layer => {\n            try {\n              if (layer && mapRef.current) {\n                mapRef.current.removeLayer(layer);\n\n                // Special handling for GeoRasterLayer to free memory\n                if (layer instanceof GeoRasterLayer || layer.georaster) {\n                  // Clear any cached tiles\n                  if (layer._tiles) {\n                    Object.keys(layer._tiles).forEach(key => {\n                      delete layer._tiles[key];\n                    });\n                  }\n\n                  // Clear georaster data if possible\n                  if (layer.georaster) {\n                    if (layer.georaster.values) {\n                      layer.georaster.values.length = 0;\n                    }\n                    // Clear other large properties\n                    ['_data', '_cache', '_values'].forEach(prop => {\n                      if (layer.georaster[prop]) {\n                        layer.georaster[prop] = null;\n                      }\n                    });\n                  }\n                }\n              }\n            } catch (e) {\n              console.warn('Error removing layer:', e);\n            }\n          });\n          imageLayersRef.current = [];\n        }\n\n        // Clean up any registered event handlers\n        if (mapRef.current._cleanupHandlers && Array.isArray(mapRef.current._cleanupHandlers)) {\n          console.log(`Cleaning up ${mapRef.current._cleanupHandlers.length} event handlers`);\n          mapRef.current._cleanupHandlers.forEach(handler => {\n            if (typeof handler === 'function') {\n              try {\n                handler();\n              } catch (e) {\n                console.warn('Error cleaning up handler:', e);\n              }\n            }\n          });\n          mapRef.current._cleanupHandlers = [];\n        }\n\n        // Remove all event listeners\n        mapRef.current.off();\n\n        // Clear all tiles from the container\n        if (mapRef.current) {\n          const mapContainer = mapRef.current.getContainer();\n          const tileContainers = mapContainer.querySelectorAll('.leaflet-tile-container');\n          tileContainers.forEach((container) => {\n            if (container instanceof HTMLElement) {\n              container.innerHTML = '';\n            }\n          });\n        }\n\n        // Remove the map\n        mapRef.current.remove();\n        mapRef.current = null;\n\n        // Force garbage collection if possible\n        if (window.gc) {\n          try {\n            window.gc();\n          } catch (e) {\n            console.log('Manual garbage collection not available');\n          }\n        }\n      }\n    };\n  }, []);\n\n  // Fallback function for simple image overlay or COG handling\n  const fallbackToImageOverlay = async (image: any, mapInstance: any, bounds: any, newLayers: any[]) => {\n    console.log('Using fallback image overlay or COG handling for:', image.name);\n\n    // Calculate appropriate bounds\n    let imageBounds;\n\n    // Check if this is a Copernicus image or COG\n    const isCopernicus = image.name.includes('Copernicus') ||\n                        image.name.includes('copernicus') ||\n                        image.metadata?.type === 'image/tiff' ||\n                        image.metadata?.type === 'image/geotiff';\n\n    const isCOG = image.name.includes('COG') ||\n                  image.name.includes('cog') ||\n                  image.metadata?.isCOG;\n\n    // Try to load as COG if it's a Copernicus image or explicitly marked as COG\n    if (isCOG || isCopernicus) {\n      console.log('Attempting to load as Cloud Optimized GeoTIFF (COG):', image.name);\n\n      try {\n        // For COG files, we need to use the URL directly with parseGeoRaster\n        console.log('Loading COG from URL:', image.url);\n        console.log('COG file details:', {\n          name: image.name,\n          size: image.metadata?.size,\n          type: image.metadata?.type,\n          bounds: image.bounds\n        });\n\n        // Use georaster to load the COG directly from arrayBuffer if available\n        const georasterResult = image.arrayBuffer ? await parseGeoraster(image.arrayBuffer) : null;\n        if (!georasterResult) {\n          throw new Error('No arrayBuffer available for COG processing');\n        }\n        console.log('Successfully parsed COG:', {\n          dimensions: georasterResult.dimensions,\n          pixelWidth: georasterResult.pixelWidth,\n          pixelHeight: georasterResult.pixelHeight,\n          noDataValue: georasterResult.noDataValue,\n          projection: georasterResult.projection,\n          numberOfRasters: georasterResult.numberOfRasters,\n          bounds: [georasterResult.xmin, georasterResult.ymin, georasterResult.xmax, georasterResult.ymax]\n        });\n\n        // Calculate appropriate resolution based on image size and current zoom\n        // Make sure mapInstance is not null\n        if (!mapInstance) {\n          console.error('Map instance is null when trying to get zoom level');\n          return null;\n        }\n\n        const currentZoom = mapInstance.getZoom();\n\n        // Calculate optimal resolution based on zoom level\n        // Use a more sophisticated algorithm for resolution calculation\n        // Lower zoom levels (overview): use lower resolution for performance\n        // Higher zoom levels (detail): use higher resolution for clarity\n        const baseResolution = 256;\n\n        // Exponential scaling for better performance at different zoom levels\n        // This provides better low-res overview at low zoom and high detail at high zoom\n        const zoomFactor = Math.pow(1.2, Math.min(currentZoom - 10, 8));\n        const zoomAdjustedFactor = Math.max(0.5, Math.min(2.5, zoomFactor));\n        const resolution = Math.round(baseResolution * zoomAdjustedFactor);\n\n        // Limit resolution to reasonable bounds based on screen size\n        const maxScreenDimension = Math.max(window.innerWidth, window.innerHeight);\n        const maxResolution = Math.min(512, Math.round(maxScreenDimension / 2));\n        const finalResolution = Math.min(resolution, maxResolution);\n\n        if (Math.random() < 0.1) { // Reduce logging frequency\n            console.log(`Using optimized resolution for COG: ${finalResolution} at zoom level ${currentZoom}`);\n        }\n\n        // Create the GeoRasterLayer with advanced settings optimized for performance\n        const geoRasterLayer = new GeoRasterLayer({\n          georaster: georasterResult,\n          opacity: 0.9,\n          // Use a moderate resolution that balances quality and performance\n          resolution: 256, // Reduced from 512 for better performance during zooming\n          // Enable caching for better performance during zoom/pan\n          debugLevel: 0,\n          // Set a shorter render timeout for faster response\n          renderTimeout: 2000,\n          // Optimize buffer and update settings for better zooming performance\n          keepBuffer: 4, // Reduced buffer size for better performance\n          updateWhenIdle: true, // Only update when idle for better performance\n          updateWhenZooming: false, // Don't update during zoom for better performance\n          resampleMethod: 'nearest', // Faster than bilinear for most cases\n          pixelValuesToColorFn: values => {\n            // For false color images or multi-band images\n            if (values.length >= 3) {\n              // Get the first three bands for RGB visualization\n              let r = values[0];\n              let g = values[1];\n              let b = values[2];\n\n              // Check if values are very small (near zero) or very large\n              const maxVal = Math.max(...[r, g, b].filter(v => isFinite(v)));\n\n              // If values are very large (likely 16-bit data)\n              if (maxVal > 255) {\n                // Scale down to 8-bit range\n                const scaleFactor = 255 / maxVal;\n                r = Math.round(r * scaleFactor);\n                g = Math.round(g * scaleFactor);\n                b = Math.round(b * scaleFactor);\n              }\n              // If values are very small (likely normalized data)\n              else if (maxVal <= 1 && maxVal > 0) {\n                // Scale up to 0-255 range\n                r = Math.round(r * 255);\n                g = Math.round(g * 255);\n                b = Math.round(b * 255);\n              }\n\n              // Ensure values are in valid range\n              r = Math.min(255, Math.max(0, r || 0));\n              g = Math.min(255, Math.max(0, g || 0));\n              b = Math.min(255, Math.max(0, b || 0));\n\n              return `rgb(${r}, ${g}, ${b})`;\n            }\n            // For single-band data (grayscale)\n            else if (values.length === 1) {\n              let val = values[0];\n\n              // Check if value is very small or very large\n              if (val > 255) {\n                // Scale down to 8-bit\n                val = Math.round(val * (255 / Math.max(val, 1)));\n              } else if (val <= 1 && val > 0) {\n                // Scale up from 0-1 to 0-255\n                val = Math.round(val * 255);\n              }\n\n              val = Math.min(255, Math.max(0, val || 0));\n              return `rgb(${val}, ${val}, ${val})`;\n            }\n            // For multi-band data beyond 3 bands (false color)\n            else if (values.length > 3) {\n              // Use the first three bands for visualization\n              let r = values[0];\n              let g = values[1];\n              let b = values[2];\n\n              // Apply scaling as needed\n              const maxVal = Math.max(...[r, g, b].filter(v => isFinite(v)));\n              if (maxVal > 255) {\n                const scaleFactor = 255 / maxVal;\n                r = Math.round(r * scaleFactor);\n                g = Math.round(g * scaleFactor);\n                b = Math.round(b * scaleFactor);\n              }\n\n              r = Math.min(255, Math.max(0, r || 0));\n              g = Math.min(255, Math.max(0, g || 0));\n              b = Math.min(255, Math.max(0, b || 0));\n\n              return `rgb(${r}, ${g}, ${b})`;\n            }\n\n            // Default fallback\n            return 'rgb(128, 128, 128)'; // Gray as fallback\n          }\n        });\n\n        if (mapInstance) {\n          geoRasterLayer.addTo(mapInstance);\n        }\n        const layer = geoRasterLayer;\n\n        // Get bounds from the georaster\n        const georasterBounds = L.latLngBounds([\n          [georasterResult.ymin, georasterResult.xmin],\n          [georasterResult.ymax, georasterResult.xmax]\n        ]);\n\n        bounds.extend(georasterBounds);\n        console.log('Added COG layer with bounds:', georasterBounds);\n        return layer;\n      } catch (cogError) {\n        console.warn('Failed to load COG, falling back to simple image overlay:', cogError);\n      }\n    }\n\n    // If we reach here, we couldn't create a georaster, so show an error\n    console.warn('Could not create georaster for image, showing error bounds');\n\n    if (image.bounds && image.bounds.length === 4) {\n      imageBounds = L.latLngBounds(\n        [image.bounds[1], image.bounds[0]], // Southwest corner [lat, lng]\n        [image.bounds[3], image.bounds[2]]  // Northeast corner [lat, lng]\n      );\n    } else {\n      console.warn('No valid bounds found for image, using default bounds');\n      imageBounds = L.latLngBounds([[-90, -180], [90, 180]]);\n    }\n\n    // Add a warning rectangle with text instead of trying to show the image\n    const warningRectangle = L.rectangle(imageBounds, {\n      color: \"#ff0000\",\n      weight: 2,\n      opacity: 0.8,\n      fillColor: \"#ffcccc\",\n      fillOpacity: 0.3\n    });\n\n    if (mapInstance) {\n      warningRectangle.addTo(mapInstance);\n    }\n\n    const errorMessage = \"Could not process GeoTIFF image. The file may be corrupted or in an unsupported format.\";\n\n    // Add a warning tooltip with error message\n    warningRectangle.bindTooltip(errorMessage, {\n      permanent: true,\n      direction: 'center',\n      className: 'image-error-tooltip'\n    }).openTooltip();\n\n    // Add to layers for cleanup\n    newLayers.push(warningRectangle);\n    return warningRectangle;\n  };\n\n  // Add satellite images to the map\n  useEffect(() => {\n    const mapInstance = mapRef.current;\n    if (!mapInstance || !isMapInitialized || images.length === 0) return;\n\n    console.log(`GeoRasterLeafletMap: Processing ${images.length} images`);\n    console.log('Images to process:', images.map(img => ({\n      id: img.id,\n      name: img.name,\n      bounds: img.bounds,\n      hasGeoraster: !!img.georaster,\n      url: img.url,\n      metadata: img.metadata\n    })));\n\n    // Log more detailed information about the georaster if available\n    images.forEach(img => {\n      if (img.georaster) {\n        console.log(`Detailed georaster info for ${img.name}:`, {\n          dimensions: img.georaster.dimensions,\n          pixelWidth: img.georaster.pixelWidth,\n          pixelHeight: img.georaster.pixelHeight,\n          noDataValue: img.georaster.noDataValue,\n          projection: img.georaster.projection,\n          numberOfRasters: img.georaster.numberOfRasters,\n          bounds: [img.georaster.xmin, img.georaster.ymin, img.georaster.xmax, img.georaster.ymax],\n          rasterType: img.georaster.rasterType,\n          dataType: img.georaster.dataType,\n          values: img.georaster.values ? 'Available' : 'Not available'\n        });\n      }\n    });\n\n    // Remove existing image layers\n    imageLayersRef.current.forEach(layer => {\n      mapInstance.removeLayer(layer);\n    });\n    imageLayersRef.current = [];\n\n    // Process each image\n    const processImages = async () => {\n      const newLayers = [];\n      const bounds = L.latLngBounds([]);\n\n      for (const image of images) {\n        try {\n          console.log(`Processing image: ${image.name}`, image);\n\n          let layer;\n\n          // Check if this is a stored image with processed blob (no heavy processing needed)\n          if ((image as any).processedBlob || (image.url && !image.georaster && !image.arrayBuffer)) {\n            console.log('Using stored processed image with URL:', image.url);\n            \n            if (image.url && image.bounds && image.bounds.length === 4) {\n              // Create simple image overlay for stored processed images\n              const imageBounds = L.latLngBounds(\n                [image.bounds[1], image.bounds[0]], // Southwest corner [lat, lng]\n                [image.bounds[3], image.bounds[2]]  // Northeast corner [lat, lng]\n              );\n              \n              const imageOverlay = L.imageOverlay(image.url, imageBounds, {\n                opacity: 0.8,\n                interactive: true\n              });\n              \n              if (mapInstance) {\n                imageOverlay.addTo(mapInstance);\n              }\n              \n              // Add popup with image info\n              imageOverlay.bindPopup(`\n                <div style=\"text-align: center;\">\n                  <h4>${image.name}</h4>\n                  <p>Processed satellite image</p>\n                  <p>Uploaded: ${new Date(image.timestamp).toLocaleString()}</p>\n                </div>\n              `);\n              \n              layer = imageOverlay;\n              bounds.extend(imageBounds);\n              console.log('Added stored image overlay with bounds:', imageBounds);\n            } else {\n              console.warn('Stored image missing URL or bounds:', image);\n            }\n          }\n          // Check if we have a georaster already (freshly processed images)\n          else if (image.georaster) {\n            console.log('Using existing georaster');\n\n            // Create a GeoRasterLayer with the existing georaster\n            const geoRasterLayer = new GeoRasterLayer({\n              georaster: image.georaster,\n              opacity: 0.9,\n              resolution: 256,\n              pixelValuesToColorFn: values => {\n                console.log('Pixel values for existing georaster:', values);\n\n                // For false color images or multi-band images\n                if (values.length >= 3) {\n                  // Get the first three bands for RGB visualization\n                  let r = values[0];\n                  let g = values[1];\n                  let b = values[2];\n\n                  // Check if values are very small (near zero) or very large\n                  const maxVal = Math.max(...[r, g, b].filter(v => isFinite(v)));\n\n                  // If values are very large (likely 16-bit data)\n                  if (maxVal > 255) {\n                    // Scale down to 8-bit range\n                    const scaleFactor = 255 / maxVal;\n                    r = Math.round(r * scaleFactor);\n                    g = Math.round(g * scaleFactor);\n                    b = Math.round(b * scaleFactor);\n                  }\n                  // If values are very small (likely normalized data)\n                  else if (maxVal <= 1 && maxVal > 0) {\n                    // Scale up to 0-255 range\n                    r = Math.round(r * 255);\n                    g = Math.round(g * 255);\n                    b = Math.round(b * 255);\n                  }\n\n                  // Ensure values are in valid range\n                  r = Math.min(255, Math.max(0, r || 0));\n                  g = Math.min(255, Math.max(0, g || 0));\n                  b = Math.min(255, Math.max(0, b || 0));\n\n                  return `rgb(${r}, ${g}, ${b})`;\n                }\n                // For single-band data (grayscale)\n                else if (values.length === 1) {\n                  let val = values[0];\n\n                  // Check if value is very small or very large\n                  if (val > 255) {\n                    // Scale down to 8-bit\n                    val = Math.round(val * (255 / Math.max(val, 1)));\n                  } else if (val <= 1 && val > 0) {\n                    // Scale up from 0-1 to 0-255\n                    val = Math.round(val * 255);\n                  }\n\n                  val = Math.min(255, Math.max(0, val || 0));\n                  return `rgb(${val}, ${val}, ${val})`;\n                }\n                // For multi-band data beyond 3 bands (false color)\n                else if (values.length > 3) {\n                  // Use the first three bands for visualization\n                  let r = values[0];\n                  let g = values[1];\n                  let b = values[2];\n\n                  // Apply scaling as needed\n                  const maxVal = Math.max(...[r, g, b].filter(v => isFinite(v)));\n                  if (maxVal > 255) {\n                    const scaleFactor = 255 / maxVal;\n                    r = Math.round(r * scaleFactor);\n                    g = Math.round(g * scaleFactor);\n                    b = Math.round(b * scaleFactor);\n                  }\n\n                  r = Math.min(255, Math.max(0, r || 0));\n                  g = Math.min(255, Math.max(0, g || 0));\n                  b = Math.min(255, Math.max(0, b || 0));\n\n                  return `rgb(${r}, ${g}, ${b})`;\n                }\n\n                // Default fallback\n                return 'rgb(128, 128, 128)'; // Gray as fallback\n              }\n            });\n\n            geoRasterLayer.addTo(mapInstance);\n            layer = geoRasterLayer;\n\n            // Get bounds from the georaster\n            const georasterBounds = L.latLngBounds([\n              [image.georaster.ymin, image.georaster.xmin],\n              [image.georaster.ymax, image.georaster.xmax]\n            ]);\n\n            bounds.extend(georasterBounds);\n            console.log('Added georaster layer with bounds:', georasterBounds);\n          }\n          // For GeoTIFF files, try to create a georaster\n          else if (image.arrayBuffer && !image.metadata?.isJP2) {\n            try {\n              console.log('Trying to parse arrayBuffer to create georaster');\n\n              // Try to parse the arrayBuffer directly\n              try {\n                console.log('Attempting to parse GeoTIFF from arrayBuffer');\n                const georasterResult = await parseGeoraster(image.arrayBuffer);\n\n                // Calculate appropriate resolution based on image size and current zoom\n                // Make sure mapInstance is not null\n                if (!mapInstance) {\n                  console.error('Map instance is null when trying to get zoom level for GeoTIFF');\n                  return;\n                }\n\n                const currentZoom = mapInstance.getZoom();\n\n                // Calculate optimal resolution based on zoom level\n                // Use a more sophisticated algorithm for resolution calculation\n                // Lower zoom levels (overview): use lower resolution for performance\n                // Higher zoom levels (detail): use higher resolution for clarity\n                const baseResolution = 256;\n\n                // Exponential scaling for better performance at different zoom levels\n                // This provides better low-res overview at low zoom and high detail at high zoom\n                const zoomFactor = Math.pow(1.2, Math.min(currentZoom - 10, 8));\n                const zoomAdjustedFactor = Math.max(0.5, Math.min(2.5, zoomFactor));\n                const resolution = Math.round(baseResolution * zoomAdjustedFactor);\n\n                // Limit resolution to reasonable bounds based on screen size\n                const maxScreenDimension = Math.max(window.innerWidth, window.innerHeight);\n                const maxResolution = Math.min(512, Math.round(maxScreenDimension / 2));\n                const finalResolution = Math.min(resolution, maxResolution);\n\n                if (Math.random() < 0.1) { // Reduce logging frequency\n                    console.log(`Using optimized resolution for GeoTIFF: ${finalResolution} at zoom level ${currentZoom}`);\n                }\n\n                // Create a loading indicator\n                const loadingIndicator = new L.Control({ position: 'topright' });\n                loadingIndicator.onAdd = function() {\n                  const div = L.DomUtil.create('div', 'loading-indicator');\n                  div.innerHTML = '<div class=\"spinner\">Loading...</div>';\n                  div.style.display = 'none';\n                  div.style.padding = '5px 10px';\n                  div.style.background = 'rgba(255, 255, 255, 0.8)';\n                  div.style.borderRadius = '4px';\n                  div.style.margin = '10px';\n                  div.style.fontWeight = 'bold';\n                  return div;\n                };\n\n                if (mapInstance) {\n                  loadingIndicator.addTo(mapInstance);\n                }\n\n                // Create the GeoRasterLayer with advanced settings optimized for performance\n                const geoRasterLayer = new GeoRasterLayer({\n                  georaster: georasterResult,\n                  opacity: 0.9,\n                  // Use a moderate resolution that balances quality and performance\n                  resolution: 256, // Reduced from 512 for better performance during zooming\n                  // Enable caching for better performance during zoom/pan\n                  debugLevel: 0,\n                  // Set a shorter render timeout for faster response\n                  renderTimeout: 2000,\n                  // Optimize buffer and update settings for better zooming performance\n                  keepBuffer: 4, // Reduced buffer size for better performance\n                  updateWhenIdle: true, // Only update when idle for better performance\n                  updateWhenZooming: false, // Don't update during zoom for better performance\n                  resampleMethod: 'nearest', // Faster than bilinear for most cases\n                  pixelValuesToColorFn: values => {\n                    // For false color images or multi-band images\n                    if (values.length >= 3) {\n                      // Get the first three bands for RGB visualization\n                      let r = values[0];\n                      let g = values[1];\n                      let b = values[2];\n\n                      // Check if values are very small (near zero) or very large\n                      const maxVal = Math.max(...[r, g, b].filter(v => isFinite(v)));\n\n                      // If values are very large (likely 16-bit data)\n                      if (maxVal > 255) {\n                        // Scale down to 8-bit range\n                        const scaleFactor = 255 / maxVal;\n                        r = Math.round(r * scaleFactor);\n                        g = Math.round(g * scaleFactor);\n                        b = Math.round(b * scaleFactor);\n                      }\n                      // If values are very small (likely normalized data)\n                      else if (maxVal <= 1 && maxVal > 0) {\n                        // Scale up to 0-255 range\n                        r = Math.round(r * 255);\n                        g = Math.round(g * 255);\n                        b = Math.round(b * 255);\n                      }\n\n                      // Ensure values are in valid range\n                      r = Math.min(255, Math.max(0, r || 0));\n                      g = Math.min(255, Math.max(0, g || 0));\n                      b = Math.min(255, Math.max(0, b || 0));\n\n                      return `rgb(${r}, ${g}, ${b})`;\n                    }\n                    // For single-band data (grayscale)\n                    else if (values.length === 1) {\n                      let val = values[0];\n\n                      // Check if value is very small or very large\n                      if (val > 255) {\n                        // Scale down to 8-bit\n                        val = Math.round(val * (255 / Math.max(val, 1)));\n                      } else if (val <= 1 && val > 0) {\n                        // Scale up from 0-1 to 0-255\n                        val = Math.round(val * 255);\n                      }\n\n                      val = Math.min(255, Math.max(0, val || 0));\n                      return `rgb(${val}, ${val}, ${val})`;\n                    }\n                    // For multi-band data beyond 3 bands (false color)\n                    else if (values.length > 3) {\n                      // Use the first three bands for visualization\n                      let r = values[0];\n                      let g = values[1];\n                      let b = values[2];\n\n                      // Apply scaling as needed\n                      const maxVal = Math.max(...[r, g, b].filter(v => isFinite(v)));\n                      if (maxVal > 255) {\n                        const scaleFactor = 255 / maxVal;\n                        r = Math.round(r * scaleFactor);\n                        g = Math.round(g * scaleFactor);\n                        b = Math.round(b * scaleFactor);\n                      }\n\n                      r = Math.min(255, Math.max(0, r || 0));\n                      g = Math.min(255, Math.max(0, g || 0));\n                      b = Math.min(255, Math.max(0, b || 0));\n\n                      return `rgb(${r}, ${g}, ${b})`;\n                    }\n\n                    // Default fallback\n                    return 'rgb(128, 128, 128)'; // Gray as fallback\n                  }\n                });\n\n                geoRasterLayer.addTo(mapInstance);\n                layer = geoRasterLayer;\n\n                // Get bounds from the georaster\n                const georasterBounds = L.latLngBounds([\n                  [georasterResult.ymin, georasterResult.xmin],\n                  [georasterResult.ymax, georasterResult.xmax]\n                ]);\n\n                bounds.extend(georasterBounds);\n                console.log('Created and added georaster layer with bounds using COG approach:', georasterBounds);\n\n                // Use a performance-optimized approach for zooming\n                // that prioritizes responsiveness over quality during zoom operations\n\n                // Calculate a moderate resolution that balances quality and performance\n                // Lower resolution for better performance, especially during zooming\n                const optimalBaseResolution = 256; // Reduced from 512 for better performance\n\n                // Apply optimized settings to the GeoRasterLayer\n                (geoRasterLayer.options as any).resolution = optimalBaseResolution;\n\n                // Optimize rendering settings for better performance\n                (geoRasterLayer.options as any).updateWhenZooming = false; // Don't update during zoom for better performance\n                (geoRasterLayer.options as any).keepBuffer = 4; // Reduced buffer size for better performance\n                (geoRasterLayer.options as any).renderTimeout = 2000; // Shorter timeout for faster response\n\n                // Create a throttled zoom handler to prevent excessive rendering\n                // This helps reduce the number of times the loading indicator is shown/hidden\n                let zoomThrottleTimer: number | null = null;\n                const throttleDelay = 300; // ms between zoom handler executions\n\n                // Add a subtle loading indicator during zoom without changing resolution\n                const zoomStartHandler = () => {\n                  if (!mapInstance) return;\n\n                  // Clear any existing timer\n                  if (zoomThrottleTimer !== null) {\n                    window.clearTimeout(zoomThrottleTimer);\n                    zoomThrottleTimer = null;\n                  }\n\n                  // Show loading indicator with throttling\n                  zoomThrottleTimer = window.setTimeout(() => {\n                    const loadingElement = document.querySelector('.loading-indicator') as HTMLElement;\n                    if (loadingElement) {\n                      loadingElement.style.display = 'block';\n                      loadingElement.style.opacity = '0.5'; // Make it subtle\n                    }\n                  }, 100); // Short delay before showing indicator\n                };\n\n                // Hide the loading indicator when zoom ends, but don't redraw the layer\n                const zoomEndHandler = () => {\n                  if (!mapInstance) return;\n\n                  // Clear any existing timer\n                  if (zoomThrottleTimer !== null) {\n                    window.clearTimeout(zoomThrottleTimer);\n                    zoomThrottleTimer = null;\n                  }\n\n                  // Hide loading indicator with throttling\n                  zoomThrottleTimer = window.setTimeout(() => {\n                    const loadingElement = document.querySelector('.loading-indicator') as HTMLElement;\n                    if (loadingElement) {\n                      loadingElement.style.display = 'none';\n                    }\n                    // Force a single redraw after zoom completes for better quality\n                    mapInstance.invalidateSize({ pan: false });\n                  }, throttleDelay);\n                };\n\n                // Add the zoom handlers (with null check)\n                if (mapInstance) {\n                  // Register both zoomstart and zoomend events\n                  mapInstance.on('zoomstart', zoomStartHandler);\n                  mapInstance.on('zoomend', zoomEndHandler);\n\n                  // Store the handlers for cleanup\n                  const cleanupHandler = () => {\n                    if (mapInstance) {\n                      mapInstance.off('zoomstart', zoomStartHandler);\n                      mapInstance.off('zoomend', zoomEndHandler);\n                    }\n                  };\n\n                  // Add to cleanup list (with type safety)\n                  if (!mapInstance._cleanupHandlers) {\n                    mapInstance._cleanupHandlers = [];\n                  }\n                  mapInstance._cleanupHandlers.push(cleanupHandler);\n                }\n\n                return;\n              } catch (parseError) {\n                console.warn('Failed to parse GeoTIFF from arrayBuffer:', parseError);\n                throw parseError;\n              }\n            } catch (error) {\n              console.error('Error creating georaster from arrayBuffer:', error);\n              // Fall back to simple image overlay\n              layer = await fallbackToImageOverlay(image, mapInstance, bounds, newLayers);\n            }\n          }\n          // For JP2 or other files, use simple image overlay\n          else {\n            layer = await fallbackToImageOverlay(image, mapInstance, bounds, newLayers);\n          }\n\n          if (layer) {\n            newLayers.push(layer);\n          }\n        } catch (error) {\n          console.error(`Error processing image ${image.name}:`, error);\n        }\n      }\n\n      // Store references to new layers\n      imageLayersRef.current = newLayers;\n\n      // If we have layers, fit the map to the images\n      if (newLayers.length > 0) {\n        if (bounds.isValid()) {\n          console.log('Fitting map to image bounds:', bounds);\n          mapInstance.fitBounds(bounds, {\n            padding: [50, 50], // Add padding around the bounds\n            maxZoom: 18        // Limit max zoom level\n          });\n        } else {\n          console.warn('No valid bounds found for images. Using default view.');\n          // Set a default view if bounds are not valid\n          mapInstance.setView([0, 0], 2);\n\n          // Try to create bounds from image metadata\n          const defaultBounds = L.latLngBounds([]);\n          let hasValidBounds = false;\n\n          for (const image of images) {\n            if (image.bounds &&\n                isFinite(image.bounds[0]) && isFinite(image.bounds[1]) &&\n                isFinite(image.bounds[2]) && isFinite(image.bounds[3])) {\n\n              const imageBounds = L.latLngBounds(\n                [image.bounds[1], image.bounds[0]], // Southwest corner [lat, lng]\n                [image.bounds[3], image.bounds[2]]  // Northeast corner [lat, lng]\n              );\n\n              if (imageBounds.isValid()) {\n                defaultBounds.extend(imageBounds);\n                hasValidBounds = true;\n              }\n            }\n          }\n\n          if (hasValidBounds) {\n            console.log('Using alternative bounds from image metadata:', defaultBounds);\n            mapInstance.fitBounds(defaultBounds, {\n              padding: [50, 50],\n              maxZoom: 18\n            });\n          }\n        }\n      } else if (initialBounds) {\n        // Use initial bounds if provided\n        const initialLatLngBounds = L.latLngBounds(\n          [initialBounds[1], initialBounds[0]], // Southwest corner [lat, lng]\n          [initialBounds[3], initialBounds[2]]  // Northeast corner [lat, lng]\n        );\n\n        if (initialLatLngBounds.isValid()) {\n          console.log('Using provided initial bounds:', initialLatLngBounds);\n          mapInstance.fitBounds(initialLatLngBounds, {\n            padding: [50, 50],\n            maxZoom: 18\n          });\n        }\n      }\n    };\n\n    processImages();\n\n    // Enhanced cleanup function with better memory management\n    return () => {\n      if (mapRef.current) {\n        // Remove all image layers with proper cleanup\n        imageLayersRef.current.forEach(layer => {\n          try {\n            // Remove the layer from the map\n            mapRef.current?.removeLayer(layer);\n\n            // Special handling for GeoRasterLayer to free memory\n            if (layer instanceof GeoRasterLayer || (layer as any).georaster) {\n              // Clear any cached tiles\n              if ((layer as any)._tiles) {\n                Object.keys((layer as any)._tiles).forEach(key => {\n                  delete (layer as any)._tiles[key];\n                });\n              }\n\n              // Clear georaster data if possible\n              if ((layer as any).georaster) {\n                if ((layer as any).georaster.values) {\n                  (layer as any).georaster.values.length = 0;\n                }\n                // Clear other large properties\n                ['_data', '_cache', '_values'].forEach(prop => {\n                  if ((layer as any).georaster[prop]) {\n                    (layer as any).georaster[prop] = null;\n                  }\n                });\n              }\n            }\n          } catch (e) {\n            console.warn('Error during layer cleanup:', e);\n          }\n        });\n\n        // Clear the layers array\n        imageLayersRef.current = [];\n\n        // Force garbage collection if available\n        if (window.gc) {\n          try {\n            window.gc();\n          } catch (e) {\n            console.log('Manual garbage collection not available');\n          }\n        }\n      }\n    };\n  }, [images, isMapInitialized, initialBounds]);\n\n  // Add GeoJSON data to the map\n  useEffect(() => {\n    const mapInstance = mapRef.current;\n    if (!mapInstance || !isMapInitialized) return;\n\n    // Remove existing GeoJSON layer\n    if (geoJSONLayerRef.current) {\n      mapInstance.removeLayer(geoJSONLayerRef.current);\n      geoJSONLayerRef.current = null;\n    }\n\n    // Add new GeoJSON layer if data is provided\n    if (geoJSON && geoJSON.features && geoJSON.features.length > 0) {\n      console.log(`GeoRasterLeafletMap: Adding GeoJSON with ${geoJSON.features.length} features.`);\n\n      const geoJSONLayer = L.geoJSON(geoJSON as GeoJsonObject, {\n        style: {\n          color: '#ff7800',\n          weight: 5,\n          opacity: 0.65\n        },\n        onEachFeature: (feature, layer) => {\n          if (feature.properties) {\n            layer.bindTooltip(`ID: ${feature.properties.id || 'N/A'}`, { sticky: true });\n          }\n        }\n      }).addTo(mapInstance);\n\n      geoJSONLayerRef.current = geoJSONLayer;\n\n      // Fit bounds to GeoJSON if no initial bounds provided\n      if (!initialBounds) {\n        const bounds = geoJSONLayer.getBounds();\n        if (bounds.isValid()) {\n          mapInstance.fitBounds(bounds);\n        }\n      }\n    }\n  }, [geoJSON, isMapInitialized, initialBounds]);\n\n  // Set up drawing controls\n  useEffect(() => {\n    const mapInstance = mapRef.current;\n    const drawnItemsInstance = drawnItemsRef.current;\n\n    if (!mapInstance || !drawnItemsInstance || !isMapInitialized || readOnly) {\n      return;\n    }\n\n    console.log(`GeoRasterLeafletMap: Setting up draw controls (drawingEnabled: ${drawingEnabled}).`);\n\n    // Remove existing draw control if it exists\n    if (drawControlRef.current) {\n      try { mapInstance.removeControl(drawControlRef.current); } catch(e) { console.warn(\"Minor error removing old draw control\", e); }\n      drawControlRef.current = null;\n    }\n\n    // Remove existing event listeners\n    mapInstance.off(L.Draw.Event.CREATED);\n    mapInstance.off(L.Draw.Event.DELETED);\n\n    // Add new draw control if drawing is enabled\n    if (drawingEnabled) {\n      const drawControlInstance = new L.Control.Draw({\n        draw: {\n          polyline: {\n            shapeOptions: { color: '#ff7800', weight: 5, opacity: 0.65 }\n          },\n          polygon: false,\n          rectangle: false,\n          circle: false,\n          circlemarker: false,\n          marker: false\n        },\n        edit: {\n          featureGroup: drawnItemsInstance,\n          remove: true\n        }\n      });\n\n      mapInstance.addControl(drawControlInstance);\n      drawControlRef.current = drawControlInstance;\n\n      // Handle draw events\n      mapInstance.on(L.Draw.Event.CREATED, (e: any) => {\n        const layer = e.layer;\n        const type = e.layerType;\n        console.log(`GeoRasterLeafletMap: Draw Event CREATED (${type})`);\n\n        if (type === 'polyline') {\n          try {\n            // Add the layer to the feature group\n            drawnItemsInstance.addLayer(layer);\n\n            // Convert to GeoJSON\n            const feature = layer.toGeoJSON();\n            if (feature.geometry.type === 'LineString' && onLineStringCreate) {\n              // Generate a unique ID for the line\n              const id = `line-${Date.now()}-${Math.random().toString(36).substring(2, 9)}`;\n              feature.properties = { ...feature.properties, id };\n\n              // Call the callback with the created LineString\n              onLineStringCreate(feature.geometry as LineString);\n\n              // Add a tooltip with the ID\n              layer.bindTooltip(`ID: ${id}`, { sticky: true });\n            }\n          } catch (error) {\n            console.error(\"GeoRasterLeafletMap: Error processing created geometry:\", error);\n          }\n        }\n      });\n\n      mapInstance.on(L.Draw.Event.DELETED, (e: any) => {\n        console.log(\"GeoRasterLeafletMap: Draw Event DELETED\");\n        const layers = e.layers;\n\n        layers.eachLayer((layer: any) => {\n          if (layer.toGeoJSON && onLineStringDelete) {\n            const feature = layer.toGeoJSON();\n            if (feature.properties && feature.properties.id) {\n              onLineStringDelete(feature.properties.id);\n            }\n          }\n        });\n      });\n    }\n\n    // Cleanup function\n    return () => {\n      if (mapRef.current && drawControlRef.current) {\n        try { mapRef.current.removeControl(drawControlRef.current); } catch (e) { console.warn(\"Minor error removing draw control on effect cleanup\", e); }\n        drawControlRef.current = null;\n      }\n      if (mapRef.current) {\n        mapRef.current.off(L.Draw.Event.CREATED);\n        mapRef.current.off(L.Draw.Event.DELETED);\n      }\n    };\n  }, [drawingEnabled, isMapInitialized, onLineStringCreate, onLineStringDelete, readOnly]);\n\n  // Add a useEffect to force a map refresh when images change\n  useEffect(() => {\n    if (mapRef.current && isMapInitialized && images.length > 0) {\n      // Force a refresh of the map by triggering a resize event\n      // This helps with rendering issues, especially for image overlays\n      const refreshMap = () => {\n        if (mapRef.current) {\n          mapRef.current.invalidateSize();\n          console.log('Map size invalidated to force refresh');\n\n          // Also try to fit to bounds again if possible\n          const bounds = L.latLngBounds([]);\n          let hasValidBounds = false;\n\n          // Try to create bounds from all images\n          for (const image of images) {\n            if (image.bounds &&\n                isFinite(image.bounds[0]) && isFinite(image.bounds[1]) &&\n                isFinite(image.bounds[2]) && isFinite(image.bounds[3])) {\n\n              const imageBounds = L.latLngBounds(\n                [image.bounds[1], image.bounds[0]], // Southwest corner [lat, lng]\n                [image.bounds[3], image.bounds[2]]  // Northeast corner [lat, lng]\n              );\n\n              if (imageBounds.isValid()) {\n                bounds.extend(imageBounds);\n                hasValidBounds = true;\n              }\n            }\n          }\n\n          if (hasValidBounds) {\n            console.log('Refitting map to bounds after refresh:', bounds);\n            mapRef.current.fitBounds(bounds, {\n              padding: [50, 50],\n              maxZoom: 18\n            });\n          }\n        }\n      };\n\n      // Refresh multiple times to ensure rendering\n      setTimeout(refreshMap, 100);\n      setTimeout(refreshMap, 500);\n      setTimeout(refreshMap, 1000);\n    }\n  }, [images, isMapInitialized]);\n\n  return (\n    <div\n      id=\"georaster-leaflet-map\"\n      style={{\n        height: '100%',\n        width: '100%',\n        minHeight: '500px',\n        position: 'relative',\n        overflow: 'hidden'\n      }}\n    ></div>\n  );\n};\n\nGeoRasterLeafletMap.displayName = 'GeoRasterLeafletMapComponent';\nexport default GeoRasterLeafletMap;\n","import { useState, useEffect, useCallback } from 'react';\nimport { useNavigate } from 'react-router-dom';\nimport { ArrowLeftIcon, ArrowRightIcon, PencilIcon, TrashIcon } from '@heroicons/react/24/outline';\nimport GeoRasterLeafletMap from '../components/maps/GeoRasterLeafletMap';\nimport { indexedDBService } from '../services/indexedDBService';\nimport { ErrorAlert } from '../components/common/ErrorAlert';\nimport type { ProcessedImage } from '../services/imageProcessor';\nimport type { FeatureCollection, LineString } from 'geojson';\n\nexport default function EnhancedShorelineDigitizationPage() {\n  const navigate = useNavigate();\n  const [images, setImages] = useState<ProcessedImage[]>([]);\n  const [shoreline, setShoreline] = useState<FeatureCollection | null>(null);\n  const [loading, setLoading] = useState<boolean>(true);\n  const [error, setError] = useState<string | null>(null);\n  const [lineStrings, setLineStrings] = useState<LineString[]>([]);\n\n  // Load satellite images and any existing digitized shoreline\n  useEffect(() => {\n    const loadData = async () => {\n      setLoading(true);\n      setError(null);\n\n      try {\n        // Load satellite images\n        const savedImages = await indexedDBService.getAllSatelliteImages();\n        if (savedImages.length === 0) {\n          setError('No satellite images found. Please upload images first.');\n          navigate('/satellite-upload');\n          return;\n        }\n        setImages(savedImages);\n\n        // Check if there's an existing digitized shoreline\n        const existingShoreline = await indexedDBService.getShorelineData('digitized-shoreline');\n        if (existingShoreline) {\n          setShoreline(existingShoreline);\n\n          // Extract LineStrings from the GeoJSON\n          const extractedLineStrings: LineString[] = [];\n          existingShoreline.features.forEach(feature => {\n            if (feature.geometry.type === 'LineString') {\n              extractedLineStrings.push(feature.geometry as LineString);\n            }\n          });\n          setLineStrings(extractedLineStrings);\n        }\n      } catch (err) {\n        console.error('Error loading data:', err);\n        setError('Failed to load data. Please try again.');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    loadData();\n  }, [navigate]);\n\n  // Handle creation of a new LineString\n  const handleLineStringCreate = useCallback((lineString: LineString) => {\n    setLineStrings(prevLineStrings => [...prevLineStrings, lineString]);\n  }, []);\n\n  // Handle deletion of a LineString\n  const handleLineStringDelete = useCallback((id: string) => {\n    setLineStrings(prevLineStrings =>\n      prevLineStrings.filter((ls, index) =>\n        (ls as any).properties?.id !== id && `line-${index + 1}` !== id\n      )\n    );\n  }, []);\n\n  // Update the shoreline GeoJSON when lineStrings change\n  useEffect(() => {\n    if (lineStrings.length > 0) {\n      const newShoreline: FeatureCollection = {\n        type: 'FeatureCollection',\n        features: lineStrings.map((lineString, index) => ({\n          type: 'Feature',\n          geometry: lineString,\n          properties: {\n            id: (lineString as any).properties?.id || `line-${index + 1}`\n          }\n        }))\n      };\n      setShoreline(newShoreline);\n    } else {\n      setShoreline(null);\n    }\n  }, [lineStrings]);\n\n  const handleBack = () => {\n    navigate('/satellite-upload');\n  };\n\n  const handleContinue = async () => {\n    if (!shoreline || shoreline.features.length === 0) {\n      setError('Please digitize at least one shoreline segment before continuing.');\n      return;\n    }\n\n    setLoading(true);\n    setError(null);\n\n    try {\n      // Store the digitized shoreline\n      await indexedDBService.storeShorelineData('digitized-shoreline', shoreline);\n\n      // Also store it as the current shoreline for the main workflow\n      await indexedDBService.storeShorelineData('current-shoreline', shoreline);\n\n      console.log('Digitized shoreline saved successfully.');\n      navigate('/segmentation');\n    } catch (err) {\n      console.error('Error saving digitized shoreline:', err);\n      setError('Failed to save digitized shoreline. Please try again.');\n      setLoading(false);\n    }\n  };\n\n  const handleClearAll = () => {\n    if (window.confirm('Are you sure you want to clear all digitized shorelines? This action cannot be undone.')) {\n      setLineStrings([]);\n      setShoreline(null);\n    }\n  };\n\n  if (loading && images.length === 0) {\n    return (\n      <div className=\"flex items-center justify-center h-screen\">\n        <div className=\"animate-spin rounded-full h-8 w-8 border-b-2 border-primary-600\"></div>\n        <p className=\"ml-4 text-gray-600\">Loading satellite images...</p>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"max-w-7xl mx-auto py-12 px-4 sm:px-6 lg:px-8\">\n      {/* Header */}\n      <div className=\"text-center mb-10\">\n        <h2 className=\"text-3xl font-extrabold text-primary-900 tracking-tight\">\n          Enhanced Shoreline Digitization\n        </h2>\n        <p className=\"mt-3 text-lg text-gray-600\">\n          Draw shoreline segments on the satellite images using the line tool.\n        </p>\n      </div>\n\n      {/* Error Display */}\n      <ErrorAlert message={error} onClose={() => setError(null)} />\n\n      {/* Instructions */}\n      <div className=\"bg-blue-50 border-l-4 border-blue-400 p-4 mb-6 rounded-md\">\n        <div className=\"flex\">\n          <div className=\"flex-shrink-0\">\n            <PencilIcon className=\"h-5 w-5 text-blue-400\" />\n          </div>\n          <div className=\"ml-3\">\n            <p className=\"text-sm text-blue-700\">\n              <strong>How to digitize:</strong> Use the line tool in the top-left corner of the map to draw shoreline segments.\n              Click to start a line, add points along the shoreline, and double-click to finish.\n              You can create multiple line segments and edit or delete them using the edit tools.\n            </p>\n          </div>\n        </div>\n      </div>\n\n      {/* Map Container */}\n      <div className=\"bg-white p-4 rounded-lg shadow-md border border-gray-200 mb-6\">\n        <div className=\"flex justify-between items-center mb-4\">\n          <div>\n            <h3 className=\"text-lg font-semibold text-gray-800\">Satellite Images ({images.length})</h3>\n            <p className=\"text-sm text-gray-600\">\n              {shoreline ? `${shoreline.features.length} shoreline segments digitized` : 'No shoreline segments digitized yet'}\n            </p>\n          </div>\n          <button\n            onClick={handleClearAll}\n            disabled={!shoreline || shoreline.features.length === 0}\n            className=\"inline-flex items-center px-3 py-2 border border-gray-300 shadow-sm text-sm leading-4 font-medium rounded-md text-gray-700 bg-white hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-primary-500 disabled:opacity-50 disabled:cursor-not-allowed\"\n          >\n            <TrashIcon className=\"h-4 w-4 mr-1\" />\n            Clear All\n          </button>\n        </div>\n        <div className=\"h-[600px] border rounded-lg overflow-hidden\">\n          <GeoRasterLeafletMap\n            images={images}\n            geoJSON={shoreline}\n            onLineStringCreate={handleLineStringCreate}\n            onLineStringDelete={handleLineStringDelete}\n            drawingEnabled={true}\n          />\n        </div>\n      </div>\n\n      {/* Action Buttons */}\n      <div className=\"flex justify-between\">\n        <button\n          onClick={handleBack}\n          className=\"inline-flex items-center justify-center bg-gray-100 text-gray-700 font-semibold px-6 py-3 text-base rounded-lg shadow-sm hover:bg-gray-200 transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-gray-300 focus:ring-offset-2\"\n        >\n          <ArrowLeftIcon className=\"mr-2 h-5 w-5\" />\n          Back to Images\n        </button>\n\n        <button\n          onClick={handleContinue}\n          disabled={!shoreline || shoreline.features.length === 0 || loading}\n          className=\"inline-flex items-center justify-center bg-primary-600 text-white font-semibold px-8 py-3 text-base rounded-lg shadow-md hover:bg-primary-700 transition duration-300 ease-in-out focus:outline-none focus:ring-2 focus:ring-primary-500 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed\"\n        >\n          {loading ? 'Saving...' : 'Continue to Segmentation'}\n          <ArrowRightIcon className=\"ml-2 h-5 w-5\" />\n        </button>\n      </div>\n    </div>\n  );\n}\n"],"names":["React.createElement","React.forwardRef","useRef","useState","useEffect","jsx","useCallback","jsxs","PencilIcon","TrashIcon","ArrowLeftIcon","ArrowRightIcon"],"mappings":"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","x_google_ignoreList":[0]}